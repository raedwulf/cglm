/*
 * Copyright (c), Recep Aslantas.
 *
 * MIT License (MIT), http://opensource.org/licenses/MIT
 * Full license can be found in the LICENSE file
 */

#include "test_common.h"

TEST_IMPL(perspective_lh_zo) {
  mat4 dst;
  const float fovy   = glm_rad(45.0f);
  const float aspect = 640/480.0f;
  const float near   = 0.1f;
  const float far    = 100.0f;

  glm_perspective_lh_zo(fovy, aspect, near, far, dst);

  /* Sanity mk. I */
  /* Longhand version of what the above function _should_ be doing */
  ASSERT(test_eq(dst[0][0], 1 / (tanf(fovy / 2) * aspect)))
  ASSERT(test_eq(dst[1][1], 1 / tanf(fovy / 2)))
  ASSERT(test_eq(dst[2][2], far / (far - near)))
  ASSERT(test_eq(dst[2][3], 1.0f))
  ASSERT(test_eq(dst[3][2], -1 * far * near / (far - near)))

  /* Sanity mk. II */
  /* "Reference values" generated by GLM's glm::perspectiveLH_ZO */
  mat4 cmp = {0};
  cmp[0][0] = 1.8106601f;
  cmp[1][1] = 2.4142134f;
  cmp[2][2] = 1.0010010f;
  cmp[2][3] = 1.0000000f;
  cmp[3][2] = -0.1001001f;

  for (uint32_t i = 0 ; i < 16 ; i++) {
    uint32_t r = i%4, c = i/4;
    ASSERT(fabsf(dst[r][c] - cmp[r][c]) < GLM_FLT_EPSILON)
  }

  TEST_SUCCESS
}

TEST_IMPL(camera_lookat) {
  mat4 view1, view2;
  vec3 center,
       eye = {0.024f, 14.6f, 67.04f},
       dir = {0.0f, 0.0f, -1.0f},
       up  = {0.0f, 1.0f, 0.0f};

  glm_vec3_add(eye, dir, center);
  glm_lookat(eye, center, up, view1);

  glm_look(eye, dir, up, view2);

  ASSERTIFY(test_assert_mat4_eq(view1, view2))

  TEST_SUCCESS
}

TEST_IMPL(camera_decomp) {
  mat4  proj, proj2;
  vec4  sizes;
  float aspect, fovy, nearVal, farVal;

  aspect  = 0.782f;
  fovy    = glm_rad(49.984f);
  nearVal = 0.1f;
  farVal  = 100.0f;

  glm_perspective(fovy, aspect, nearVal, farVal, proj);
  ASSERT(fabsf(aspect  - glm_persp_aspect(proj)) < GLM_FLT_EPSILON)
  ASSERT(fabsf(fovy    - glm_persp_fovy(proj))   < GLM_FLT_EPSILON)
  ASSERT(fabsf(49.984f - glm_deg(glm_persp_fovy(proj))) < GLM_FLT_EPSILON)

  glm_persp_sizes(proj, fovy, sizes);

  glm_frustum(-sizes[0] * 0.5f,
               sizes[0] * 0.5f,
              -sizes[1] * 0.5f,
               sizes[1] * 0.5f,
               nearVal,
               farVal,
               proj2);

  ASSERTIFY(test_assert_mat4_eq(proj, proj2))

  TEST_SUCCESS
}
